//!
//! This contains the grammar for .mcrl2 specifications.
//!
//! Considerations for PEG parsers
//! 

//! AFTER parsing we can use a PrattParser to define the associativity and 
//! precedence of operators for rules of the following shape:
//!
//! expr       =   { prefix? ~ primary ~ postfix? ~ (infix ~ prefix? ~ primary ~
//postfix? )* }
//!

//! The | operator defines a choice operator and does not mean OR with
//! backtracking. This means the following rules
//! 
//! Expr = { "Bool" ~ ASCII_ALPHANUMERIC* }
//!
//! Will match the expression "Boolean" by eating up "Bool" and leaving "ean" as
//! the remaining. However, this is undesirable since this should be an identifier
//! Boolean. This is resolved by only allowing keywords to match whenever it is not
//! by something that is part of an identifier.

/// This is a silent rule eating all the comments.
COMMENT = _{ "%" ~ (!NEWLINE ~ ANY)* }

/// This is a silent rule eating all the white space in the input.
WHITESPACE = _{ " " | "\t" | NEWLINE }

/// Identifiers
Id = @{ (ASCII_ALPHANUMERIC|"_")+ }

/// List of identifiers
IdList = { Id ~ ( "," ~ Id )* }

/// Numbers
Number = { "0|([1-9][0-9]*)" }

/// Parsing a single term
TermSpec = { SOI ~ Term ~ EOI }

/// Rules for terms f(t0, ..., tn)
Term = { Id ~ Args? }
Args = { "(" ~ Term ~ ("," ~ Term)*  ~ ")"}

/// Parsing an mCRL2 specification
MCRL2Spec = { SOI ~ (ActSpec | ConsSpec | EqnSpec | GlobVarSpec | ProcSpec | Init | MapSpec | SortSpec | VarSpec)* ~ EOI } 

/// Action specification
ActSpec = { "act" ~ ActDecl+ }

/// Declaration of actions
ActDecl = { IdList ~ ( ":" ~  SortProduct )? ~ ";" }

/// Sort specification
SortSpec = { "sort" ~ SortDecl+ } 

SortDecl = {    
        IdList ~ ";"                                                 // List of sort identifiers                                            
    |   Id ~ "=" ~ SortExpr ~ ";"                                    // Sort alias                                              
}

/// A general sort expression with infix operators.
SortExpr = {
    SortExprAtom ~ (SortExprInfix ~ SortExprAtom)*
}

/// A single sort expression
SortExprAtom = { 
        "Bool" ~ !Id                                                 // Booleans
    |   "Pos" ~ !Id                                                  // Positive numbers
    |   "Nat" ~ !Id                                                  // Natural numbers
    |   "Int" ~ !Id                                                  // Integers
    |   "Real" ~ !Id                                                 // Reals
    |   "List" ~ "(" ~ SortExpr ~ ")"                                // List sort
    |   "Set" ~ "(" ~ SortExpr ~ ")"                                 // Set sort
    |   "Bag" ~ "(" ~ SortExpr ~ ")"                                 // Bag sort
    |   "FSet" ~ "(" ~ SortExpr ~ ")"                                // Finite set sort
    |   "FBag" ~ "(" ~ SortExpr ~ ")"                                // Finite bag sort
    |   "(" ~ SortExpr ~ ")"                                         // Sort expression with parentheses
    |   "struct" ~ ConstrDeclList                                    // Structured sort
    |   Id                                                           // Sort reference
}

SortExprInfix = _{
    |   SortExprFunction
    |   SortExprProduct
}
    SortExprFunction = { "->" }
    SortExprProduct = { "#" }

/// Constructor declaration
ConstrDecl = { Id ~ ( "(" ~ ProjDeclList ~ ")" )? ~ ( "?" ~ Id )? } 

/// Constructor declaration list
ConstrDeclList = { ConstrDecl ~ ( "|" ~ ConstrDecl )* }             

/// A single sort A -> B -> ...
SortProduct = {
    SortExprAtom ~ (SortExprProduct ~ SortExprAtom)*
}

/// Data Expression
DataExpr = { DataExprAtom ~ DataExprSuffix? ~ (DataExprInfix ~ DataExprAtom ~ DataExprSuffix?)* }

// A single data expressions
DataExprAtom = {
        "true" ~ !Id                                                 // True
    |   "false" ~ !Id                                                // False
    |   "[" ~ "]"                                                    // Empty list
    |   "{" ~ "}"                                                    // Empty set
    |   "{" ~ ":" ~ "}"                                              // Empty bag
    |   "[" ~ DataExprList ~ "]"                                     // List enumeration
    |   "{" ~ BagEnumEltList ~ "}"                                   // Bag enumeration
    |   "{" ~ VarDecl ~ "|" ~ DataExpr ~ "}"                         // Set/bag comprehension
    |   "{" ~ DataExprList ~ "}"                                     // Set enumeration
    |   "(" ~ DataExpr ~ ")"                                         // Brackets
    |   "!" ~ DataExpr                                               // Negation, set complement
    |   "-" ~ DataExpr                                               // Unary minus
    |   "#" ~ DataExpr                                               // Size of a list
    |   "forall" ~ VarsDeclList ~ "." ~ DataExpr                     // Universal quantifier
    |   "exists" ~ VarsDeclList ~ "." ~ DataExpr                     // Existential quantifier
    |   "lambda" ~ VarsDeclList ~ "." ~ DataExpr                     // Lambda abstraction
    |   Number                                                       // Number
    |   Id                                                           // Identifier
}

DataExprSuffix = _{
        DataExprUpdate
    |   DataExprApplication
}
    /// Function update.
    DataExprUpdate = { "[" ~ DataExpr ~ "->" ~ DataExpr ~ "]" }
    /// Function application
    DataExprApplication = { "(" ~ DataExprList ~ ")" }

DataExprInfix = _{
        DataExprImpl
    |   DataExprDisj
    |   DataExprConj
    |   DataExprEq
    |   DataExprNeq
    |   DataExprLess
    |   DataExprLeq
    |   DataExprGeq
    |   DataExprGreater
    |   DataExprIn
    |   DataExprCons
    |   DataExprSnoc
    |   DataExprConcat
    |   DataExprAdd
    |   DataExprMinus
    |   DataExprDiv
    |   DataExprIntDiv
    |   DataExprMod
    |   DataExprMult
    |   DataExprAt
    |   DataExprWhr
}
    DataExprImpl = { "=>" }
    DataExprDisj = { "||" }
    DataExprConj = { "&&" }
    DataExprEq   = { "==" }
    DataExprNeq  = { "!=" }
    DataExprLess = { "<" }
    DataExprLeq  = { "<=" }
    DataExprGeq  = { ">=" }
    DataExprGreater = { ">" }
    DataExprIn   = { "in" }
    DataExprCons = { "|>" }
    DataExprSnoc = { "<|" }
    DataExprConcat = { "++" }
    DataExprAdd  = { "+" }
    DataExprMinus = { "-" }
    DataExprDiv  = { "/" }
    DataExprIntDiv = { "div" }
    DataExprMod  = { "mod" }
    DataExprMult = { "*" }
    DataExprAt   = { "." }
    DataExprWhr  = { "whr" }

/// List of data expressions
DataExprList = { DataExpr ~ ( "," ~ DataExpr )* }

/// Assignment x = expression
Assignment = { Id ~ "=" ~ DataExpr }

/// List of assignments
AssignmentList = { Assignment ~ ( "," ~ Assignment )* }

// Variable declarations

/// Typed variable
VarDecl = { Id ~ ":" ~ SortExpr }

/// Typed variables
VarsDecl = { IdList ~ ":" ~ SortExpr }

/// Individually typed variables
VarsDeclList = { VarsDecl ~ ( "," ~ VarsDecl )* }

/// Bag element with multiplicity
BagEnumElt = { DataExpr ~ ":" ~ DataExpr }                              

/// Elements in a finite bag
BagEnumEltList = { BagEnumElt ~ ( "," ~ BagEnumElt )* }

/// Action, process instantiation
Action = { Id ~ ( "(" ~ DataExprList ~ ")" )? }    

/// Action set        
ActIdSet = { "{" ~ IdList ~ "}" }                                               

/// List of actions
MultiAct = { Action ~ ( "|" ~ Action )* }                            

/// Multi-action label
MultActId = { Id ~ ( "|" ~ Id )* }                                      

MultActIdList = { MultActId ~ ( "," ~ MultActId )* }

/// Multi-action label set
MultActIdSet = { "{" ~ MultActIdList? ~ "}" }

/// Domain with optional projection
ProjDecl = { ( Id ~ ":" )? ~ SortExpr }                             

/// Declaration of projection functions
ProjDeclList = { ProjDecl ~ ( "," ~ ProjDecl )* }                  

/// Action synchronization
CommExpr = { Id ~ "|" ~ MultActId ~ "->" ~ Id }

/// Action synchronizations
CommExprList = { CommExpr ~ ( "," ~ CommExpr )* }

/// Action synchronization set
CommExprSet = { "{" ~ CommExprList? ~ "}" }                             

/// Action renaming
RenExpr = { Id ~ "->" ~ Id }

/// Multiple action renamings
RenExprList = { RenExpr ~ ( "," ~ RenExpr )* }

/// An action renaming set.
RenExprSet = { "{" ~ RenExprList? ~ "}" }

ProcExpr = { ProcExprUnit ~ (ProcExprInfix ~ ProcExprUnit)* }

/// Single Process expressions
ProcExprUnit = {
        "delta" ~ !Id                                            // Delta, deadlock, inaction
    |   "tau" ~ !Id                                              // Tau, hidden action, empty multi-action
    |   "block" ~ "(" ~ ActIdSet ~ "," ~ ProcExpr ~ ")"          // Block or encapsulation operator
    |   "allow" ~ "(" ~ MultActIdSet ~ "," ~ ProcExpr ~ ")"      // Allow operator
    |   "hide" ~ "(" ~ ActIdSet ~ "," ~ ProcExpr ~ ")"           // Hiding operator
    |   "rename" ~ "(" ~ RenExprSet ~ "," ~ ProcExpr ~ ")"       // Action renaming operator
    |   "comm" ~ "(" ~ CommExprSet ~ "," ~ ProcExpr ~ ")"        // Communication operator
    |   "(" ~ ProcExpr ~ ")"                                     // Brackets
    |   "sum" ~ VarsDeclList ~ "." ~ ProcExpr                    // Sum operator
    |   "dist" ~ VarsDeclList ~ "[" ~ DataExpr ~ "]"
            ~ "." ~ ProcExpr                                     // Distribution operator
    |   DataExprAtom ~ "->" ~ ProcExpr                           // If-then-else operator
            ~ "<>" ~ ProcExpr
    |   DataExprAtom ~ "->" ~ ProcExpr                           // If-then operator
    |   Id ~ "(" ~ AssignmentList? ~ ")"                         // Process instantiation with assignment shorthand
    |   Action                                                   // Action or process instantiation
}

ProcExprInfix = {
    |   "+"                                                      // Sum operator
    |   "||_"
    |   "||"
    |   "|"
    |   "<<"
    |   "."
    |   "@"
}

// Process declaration/
ProcDecl = { Id ~ ( "(" ~ VarsDeclList ~ ")" )? ~ "=" ~ ProcExpr ~ ";" }

/// Process specification
ProcSpec = { "proc" ~ ProcDecl+ }                                     

/// Initial process
Init = { "init" ~ ProcExpr ~ ";" }   

/// Typed parameters
IdsDecl = { IdList ~ ":" ~ SortExpr }                                   

/// Declaration of constructors
ConsSpec = { "cons" ~ ( IdsDecl ~ ";" )+ }

/// Declaration of mappings
MapSpec = { "map" ~ ( IdsDecl ~ ";" )+ }    

/// Declaration of global variables
GlobVarSpec = { "glob" ~ ( VarsDeclList ~ ";" )+ }                     
 
/// Declaration of variables      
VarSpec = { "var" ~ ( VarsDeclList ~ ";" )+ }                                               

/// Definition of equations
EqnSpec = { VarSpec? ~ "eqn" ~ EqnDecl+ }                               

/// Conditional equation
EqnDecl = { (DataExpr ~ "->")? ~ DataExpr ~ "=" ~ DataExpr ~ ";" }            